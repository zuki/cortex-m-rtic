# タイマーキュー

`spawn` APIがソフトウェアタスクをスケジューラに即座にスポーンするのとは
対照的に、`schedule` APIを使用すると、将来のある時点でタスクを実行する
ようスケジューリングすることができます。

`schedule` APIを使用するには、まず`#[app]`属性の`monotonic`引数を
使用してモノトニックタイマー（単調増加するタイマー）を定義しなければなりません。
この引数は、[`Monotonic`]トレイトを実装した型へのパスを取ります。この
トレイトの関連型`Instant`は、任意の単位でのタイムスタンプを表し、
`schedule` APIで広く使用されます。この型には[標準ライブラリの型][std-instant]を
モデル化することが推奨されます。

トレイト定義では示されていませんが（トレイト/型システムの制限のため）、
2つの`Instant`の減算は、`Duration`型（[`core::time::Duration`]を
参照）を返すべきであり、この`Duration`型は`TryInto<u32>`トレイトを
実装しなければなりません。このトレイトの実装は、任意の時間単位を使用する
`Duration`値を「システムタイマー(SYST)クロックサイクル」時間単位に
変換しなければなりません。変換結果は32ビット整数でなければなりません。
変換の結果が32ビット数に収まらない場合、その操作は何らかのエラー型の
エラーを返さなければなりません。

[`Monotonic`]: ../../../api/rtic/trait.Monotonic.html
[std-instant]: https://doc.rust-lang.org/std/time/struct.Instant.html
[`core::time::Duration`]: https://doc.rust-lang.org/core/time/struct.Duration.html

ARMv7+を対象とした場合、`rtic`クレートはビルトインCYCle CouNTer（CYCCNT）
に基づく`Monotonic`実装を提供しています。これはCPUの周波数でクロックする
32ビットタイマーであり、秒単位の時間間隔の追跡には適していないことに注意
してください。

コンテキストからソフトウェアタスクをスケジュールできるようにするには、
まず、タスクの名前をコンテキスト属性の`schedule`引数に示さなければいけません。
タスクをスケジューリングする際、その時点でタスクが実行されるべき（ユーザ
定義の）`Instant`を`schedule`呼び出しの最初の引数として渡さなければ
なりません。

さらに、選択された`monotonic`タイマーは、`#[init]`フェーズ中に設定と
初期化をする必要があります。これは、`cortex-m-rtic`クレートが提供する
`CYCCNT`を使用する場合*も*同様であることに注意してください。

下の例では、`foo`と`bar`の2つのタスクを`init`からスケジュールしています。
`foo`は800万クロックサイクル後に実行するようにスケジュールされており、
`bar`は400万クロックサイクル後に実行するようにスケジュールされています。
つまり、`bar`の方が先に実行するようスケジュールされているので、`foo`より先に`実行されます。

> **重要**: `schedule` APIまたは`Instant`抽象化を使用した例はQEMU上では
> 正しく動作しません。Cortex-Mのサイクルカウンタ機能が`qemu-system-arm`
> には実装されていないからです。


``` rust
{{#include ../../../../examples/schedule.rs}}
```

実際のハードウェア上でプログラムを実行すると、コンソールに次のような出力が出力されます。

``` text
{{#include ../../../../ci/expected/schedule.run}}
```

`schedule`APIが使用されている場合、ランタイムは内部的に`SysTick`割り込みハンドラとシステムタイマーペリフェラル(`SYST`)を使用するので、アプリケーションはどちらも使用できません。これは`init::Context.core`の型を`cortex_m::Peripherals`から`rtic::Peripherals`に変更することで使用できるようになります。後者の構造体は、前者のフィールドのうち、SYSTフィールドを除いた全てのフィールドを含んでいます。

## 定期的タスク

ソフトウェアタスクは、実行するようスケジュールされた時点の`Instant`に`scheduled`変数を通じてアクセスすることができます。この情報と`schedule`APIを使用して、以下の例で示すように定期的なタスクを実装することができます。

``` rust
{{#include ../../../../examples/periodic.rs}}
```

以下はは例の出力です。`schedule.foo`は`foo`の最後で呼び出されているにもかかわらず、ドリフトやジッターがゼロであることに注意してください。`scheduled`の代わりに`Instant::now`を使うと、ドリフトやジッターが発生します。

``` text
{{#include ../../../../ci/expected/periodic.run}}
```

## Baseline

`init`からスケジュールされたタスクについては、`scheduled`時間に関する正確な情報を得ることができます。ハードウェアタスクについてはその性質上非同期なので、`scheduled`時間はありません。ハードウェアタスクについては、ランタイムはタスクハンドラが実行を開始した時間を示す`start`時間を提供します。

`start`はタスクを起動したイベントの到着時間とは一致**しない**ことに注意してください。タスクの優先度やシステムの負荷によっては、`start`時間はイベント到着時間よりかなり離れている可能性があります。

スケジュールではなく*スポーンされた*ソフトウェアタスクの`scheduled`の価値はどうなると思いますか。スポーンされたタスクはそれをスポーンしたコンテキストの*ベースライン*時間を継承するというのが答えです。ハードウェアタスクのベースラインは`start`時間であり、ソフトウェアタスクのベースラインは`scheduled`時間であり、`init`のベースラインはシステムの開始時間、すなわち時刻ゼロ(`Instant::zero()`)です。`idle`には実際にはベースラインはありませんが、そこからスポーンされたタスクは`Instatnt::now()`をベースライン時間として使用するでしょう。

以下の例は*ベースライン*の異なる意味あいを示しています。

``` rust
{{#include ../../../../examples/baseline.rs}}
```

実際のハードウェア上でプログラムを実行すると、コンソールに次のような出力が出力されます。

``` text
{{#include ../../../../ci/expected/baseline.run}}
```
