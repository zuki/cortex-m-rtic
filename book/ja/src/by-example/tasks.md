# ソフトウェアタスク

RTICは、ハードウェアのイベントに反応してハードウェアから起動されるハードウェアタスクだけでなく、アプリケーションが任意の実行コンテキストから生成することができる*ソフトウェア*タスクもサポートしています。

ソフトウェアタスクには優先順位を割り当てることもできます。内部的には、割り込みハンドラからディスパッチされます。RTICでは、ソフトウェアタスクを使用する際に未使用の割り込みを`extern`ブロックで宣言する必要があります。これらの未使用の割り込みがソフトウェアタスクのディスパッチに使用されます。ソフトウェアタスクがハードウェアタスクより優れている点は、多くのタスクを1つの割り込みハンドラにマッピングできることです。

ソフトウェアタスクも`task`属性を使用して宣言しますが、`binds`引数を付けてはなりません。コンテキストからソフトウェアタスクを生成するには、そのタスクの名前がコンテキスト属性（`init`、`idle`、`task`など）の`spawn`引数に含まれていなければなりません。

以下の例は、2つの異なる優先度で実行される3つのソフトウェアタスクを示しています。3つのソフトウェアタスクは2つの割り込みハンドラにマッピングされています。


``` rust
{{#include ../../../../examples/task.rs}}
```

``` console
$ cargo run --example task
{{#include ../../../../ci/expected/task.run}}
```

## メッセージパス

ソフトウェアタスクのもう一つの利点は、タスクを生成する際にこのタスクにメッセージを渡すことができることです。メッセージペイロードの型はタスクハンドラのシグネチャで指定しなければなりません。

以下の例は、3つのタスクを示しており、そのうちの2つはメッセージを期待しています。

``` rust
{{#include ../../../../examples/message.rs}}
```

``` console
$ cargo run --example message
{{#include ../../../../ci/expected/message.run}}
```

## キャパシティ

RTICはヒープベースのメモリ割り当てはどんな形であれ、行い*ません*。メッセージを保存するために必要なメモリは静的に予約されます。デフォルトでは、フレームワークがアプリケーションのメモリフットプリントを最小化するため、各タスクのメッセージ「キャパシティ」は1です。これはタスクが実行機会を得る前に最大1つのメッセージしか渡すことができないことを意味します。各タスクはこのデフォルトを`capacity`引数を使って上書きすることができます。この引数にはタスクのメッセージバッファが保持できるメッセージ数を示す正の整数を指定します。

以下の例では、ソフトウェアタスク`foo`のキャパシティを4に設定しています。キャパシティが指定されていなければ、`USART１`の2回目の`spawn.foo`コールは失敗します（パニック）。


``` rust
{{#include ../../../../examples/capacity.rs}}
```

``` console
$ cargo run --example capacity
{{#include ../../../../ci/expected/capacity.run}}
```

## エラー処理

`spawn` API は、メッセージを送信するスペースがない場合、`Err`バリアントを返します。ほとんどのシナリオで生成されたエラーは次の2つの方法のいずれかで処理されます。

    - `unrawp`や`expect`などを使用してパニックを発生させる。この方法は、小さすぎる
      キャパシティの選択というプログラマのエラー(つまりバグ)を捕捉するために使用され
      ます。テスト中にこのパニックが発生した場合、より大きなキャパシティを選んで
      プログラムを再コンパイルすることで問題が解決する場合があります。しかし、時には
      問題をより深く掘り下げ、プラットフォームがピーク時のペイロードに対応できるか、
      あるいはプロセッサをより高速なものに交換する必要があるかをチェックするために
      アプリケーションのタイミング分析を実行する必要があることもあります。

    - 結果を無視する。ソフトによるリアルタイムアプリケーションや非リアルタイム
      アプリケーションでは、データを時折失ったり、イベントバースト中にいくつかの
      イベントへの応答に失敗しても構わない場合があります。このようなシナリオでは、
      黙って`spawn`コールを失敗させても構わないでしょう。

`spawn`コールの再試行は、通常間違ったアプローチであることに注意してください。実際にこの操作が成功することは決してないからです。なぜなら、コンテキストスイッチはより優先度の*高い*タスクへの方向にしか起きないので、優先度の低いタスクの`spawn`コールを再試行しても、スケジューラがそのタスクをディスパッチさせることはなく、そのメッセージバッファが空になることはないからです。この状況を以下のスニペットで示します。

``` rust
#[rtic::app(..)]
const APP: () = {
    #[init(spawn = [foo, bar])]
    fn init(cx: init::Context) {
        cx.spawn.foo().unwrap();
        cx.spawn.bar().unwrap();
    }

    #[task(priority = 2, spawn = [bar])]
    fn foo(cx: foo::Context) {
        // ..

        // プログラムはここで動かなくなる
        while cx.spawn.bar(payload).is_err() {
            // 失敗したらspawnコールを再試行する
        }
    }

    #[task(priority = 1)]
    fn bar(cx: bar::Context, payload: i32) {
        // ..
    }
};
```
